<!DOCTYPE html>
<!--[if lt IE 7]> <html class="lt-ie10 lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]> <html class="lt-ie10 lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]> <html class="lt-ie10 lt-ie9"> <![endif]-->
<!--[if IE 9]> <html class="lt-ie10"> <![endif]-->
<!--[if gt IE 9]><!--> <html> <!--<![endif]-->
<head>
    <meta content="width=980" id="viewport" name="viewport">
    <title>BotanJS - vim</title>

    <meta name="description" content="Yet another vim implementation attempt with textarea">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

    <link rel="stylesheet" type="text/css" href="http://s.botanjs.astropenguin.net/ocss/Astro.Penguin.Github">
    <script src="http://s.botanjs.astropenguin.net/ojs/Astro.Penguin.Github"></script>

    <link rel="stylesheet" type="text/css" href="/BotanJS-vim/vima.css" />
    <script src="/BotanJS-vim/vima.js" ></script>

    <script>window.onload=function(){BotanJS.import("Astro.Bootstrap").init();}</script>
</head>
<body>

<div class="center">
    <div class="left">
        <h1> VimArea </h1>
        <p> VimArea is a vim implementation over a textarea. There's a plenty of online Vim out there with different degree of impl and approach. </p>
        <p> This one is none the other, the goal of this implementation is to minimize the footprint for creating additional iframe or divs. </p>
        <p> This is not a traditional vim ( yet ). I recommend to use wasavi if you can. It is a more mature project. Even if this project is finished, it would not provide the functionality like wasavi does ( mostly because of the limitation of a textarea ). </p>
        <h2> Demo </h2>
        <div>
            <img src="/BotanJS-vim/gifs/vim-demo.gif" width="1000"></img>
            <ol>
                <li> This project is developed under firefox 45.0.1 </li>
                <li> Tested in Microsoft Edge </li>
                <li> Google Chrome? Nope, would not test. You should use wasavi tho. </li>
            </ol>
        </div>
        <div>
            <h3> Typical setup </h3>
            <pre>
var vimArea = document.getElementById( "vim-area" );
vimArea.value = TestString;
var VimArea = new ( BotanJS.import( "Components.Vim.VimArea" ) )( vimArea );
            </pre>
        </div>
        <div>
            <textarea id="vim-area" class="vima" rows="25" cols="90" spellcheck="false"></textarea>
        </div>
        <div>
			<h3> Experimental - Detect screen size </h3>
            <pre>
var vimArea = document.getElementById( "vim-area" );
vimArea.value = TestString;
var VimArea = new ( BotanJS.import( "Components.Vim.VimArea" ) )( vimArea, true );
            </pre>
            <button id="vim-init"> Create Instance for below textarea </button>
        </div>
        <div>
            <textarea id="vim-area2" class="vima" rows="25" cols="90" spellcheck="false"></textarea>
        </div>
        <h3> Source Code </h3>
        <div>
        <ol>
            <li> This page: <a href="/BotanJS-vim/vima.js">js</a>, <a href="/BotanJS-vim/vima.css" >css</a> </li>
            <li> BotanJS API ( dev, VERY unstable. May contain syntax error ):
            <br />
            js ( <a href="http://s.botanjs.astropenguin.net/rjs/Components.Vim.VimArea" target="_blank">raw</a>,
            <a href="http://s.botanjs.astropenguin.net/ojs/Components.Vim.VimArea" target="_blank">compressed</a> )
            css ( <a href="http://s.botanjs.astropenguin.net/rcss/Components.Vim.VimArea" target="_blank">raw</a>,
            <a href="http://s.botanjs.astropenguin.net/ocss/Components.Vim.VimArea" target="_blank">compressed</a> )
            </li>
            <li> Project page: <a href="https://github.com/tgckpg/BotanJS-vim">Github</a> </li>
        </ol>
        </div>
    </div>
</div>

<script>
(function(){
	var TestString = "(function(){\n\tvar ns = __namespace( \"Components.Vim.Actions\" );\n\n\t/** @type {System.Debug} */\n\tvar debug = __import( \"System.Debug\" );\n\n\t/** @type {Components.Vim.State.Stator} */\n\tvar Stator                                 = __import( \"Components.Vim.State.Stator\" );\n\t/** @type {Components.Vim.State.Stack} */\n\tvar Stack                                  = __import( \"Components.Vim.State.Stack\" );\n\n\tvar Mesg = __import( \"Components.Vim.Message\" );\n\tvar beep = __import( \"Components.Vim.Beep\" );\n\n\tvar occurence = __import( \"System.utils.Perf.CountSubstr\" );\n\n\t/** @type {Components.Vim.Cursor.IAction} */\n\tvar DELETE = function( Cursor )\n\t{\n\t\t/** @type {Components.Vim.Cursor} */\n\t\tthis.__cursor = Cursor;\n\t\tthis.__nline = 0;\n\t\tthis.__startX = Cursor.aPos;\n\t\tthis.__panY = this.__cursor.feeder.panY;\n\n\t\tCursor.suppressEvent();\n\t};\n\n\tDELETE.prototype.allowMovement = true;\n\n\tDELETE.prototype.dispose = function()\n\t{\n\t\tthis.__cursor.unsuppressEvent();\n\t};\n\n\tDELETE.prototype.handler = function( e, sp )\n\t{\n\t\te.preventDefault();\n\n\t\tif( e.ModKeys ) return;\n\n\t\t/** @type {Components.Vim.State.Registers} */\n\t\tvar reg = e.target.registers;\n\n\t\tvar cur = this.__cursor;\n\t\tvar feeder = cur.feeder;\n\n\t\tvar Triggered = false;\n\t\tvar newLine = false;\n\n\t\tif( sp == undefined )\n\t\t{\n\t\t\tTriggered = true;\n\n\t\t\tsp = this.__startX;\n\n\t\t\tvar currAp = cur.aPos;\n\t\t\tif( this.__startX != currAp )\n\t\t\t{\n\t\t\t\t// Remove to start\n\t\t\t\tif( e.kMap( \"^\" ) )\n\t\t\t\t{\n\t\t\t\t\tsp --;\n\t\t\t\t}\n\t\t\t\t// Remove char in cursor\n\t\t\t\telse if( e.kMap( \"l\" ) )\n\t\t\t\t{\n\t\t\t\t\tcur.moveX( -1 );\n\t\t\t\t}\n\t\t\t\t// Remove char before cursor\n\t\t\t\telse if( e.kMap( \"h\" ) )\n\t\t\t\t{\n\t\t\t\t\tsp = currAp;\n\t\t\t\t}\n\t\t\t\t// Remove the current and the following line\n\t\t\t\telse if( e.kMap( \"j\" ) )\n\t\t\t\t{\n\t\t\t\t\tnewLine = true;\n\t\t\t\t\tcur.lineEnd( true );\n\t\t\t\t\tsp = cur.aPos;\n\t\t\t\t\tcur.moveY( -1 );\n\t\t\t\t\tcur.lineStart();\n\t\t\t\t\tthis.__startX = cur.aPos;\n\t\t\t\t}\n\t\t\t\t// Remove the current and the preceding line\n\t\t\t\telse if( e.kMap( \"k\" ) )\n\t\t\t\t{\n\t\t\t\t\tnewLine = true;\n\t\t\t\t\tcur.moveY( 1 );\n\t\t\t\t\tcur.lineEnd( true );\n\t\t\t\t\tsp = cur.aPos;\n\t\t\t\t\tcur.moveY( -1 );\n\t\t\t\t\tcur.lineStart();\n\t\t\t\t}\n\t\t\t\telse if( this.__startX < currAp )\n\t\t\t\t{\n\t\t\t\t\t// Swap the movement\n\t\t\t\t\t// This is to move the REDO / UNDO Cursor\n\t\t\t\t\t// position to the earlier position\n\t\t\t\t\tsp = currAp;\n\t\t\t\t\tcur.moveTo( this.__startX );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Remove the current line\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( e.kMap( \"d\" ) )\n\t\t\t\t{\n\t\t\t\t\tnewLine = true;\n\t\t\t\t\tcur.lineEnd( true );\n\t\t\t\t\tsp = cur.aPos;\n\t\t\t\t\tcur.lineStart();\n\t\t\t\t}\n\t\t\t\telse if( e.range )\n\t\t\t\t{\n\t\t\t\t\tsp = e.range.close;\n\t\t\t\t\tcur.moveTo( e.range.open, true );\n\t\t\t\t}\n\t\t\t\telse if( e.kMap( \"^\" ) )\n\t\t\t\t{\n\t\t\t\t\t// Do nothing as nothing can be removed\n\t\t\t\t\t// since there is no successful movement\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// this is the same as kMap( \"h\" ) above\n\t\t\t\telse if( e.kMap( \"$\" ) )\n\t\t\t\t{\n\t\t\t\t\tsp = cur.aPos;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbeep();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar c = feeder.content;\n\n\t\tvar s = sp;\n\t\tvar e = cur.aPos;\n\n\t\tif( e < s )\n\t\t{\n\t\t\ts = cur.aPos;\n\t\t\te = sp;\n\t\t}\n\n\t\tvar removed = c.substring( s, e + 1 );\n\t\treg.change( removed, newLine );\n\n\t\tthis.__nline = occurence( removed, \"\n\" );\n\n\t\tfeeder.content = c.substring( 0, s ) + c.substring( e + 1 );\n\n\t\t// Try to keep the original panning if possible\n\t\tfeeder.pan( undefined\n\t\t\t, this.__panY < feeder.panY\n\t\t\t\t? this.__panY - feeder.panY\n\t\t\t\t: undefined\n\t\t);\n\t\tcur.moveTo( s );\n\n\t\tvar stator = new Stator( cur, s );\n\t\tvar stack = new Stack();\n\n\t\tvar f = stator.save( 0, removed );\n\t\tstack.store( function() {\n\t\t\tf();\n\t\t\t// Offset correction after REDO / UNDO\n\t\t\tcur.moveX( 1 );\n\t\t} );\n\n\t\tcur.rec.record( stack );\n\n\t\treturn Triggered;\n\t};\n\n\tDELETE.prototype.getMessage = function()\n\t{\n\t\tif( this.__nline )\n\t\t{\n\t\t\treturn Mesg( \"LINES_FEWER\", this.__nline );\n\t\t}\n\n\t\treturn \"\";\n\t};\n\n\tns[ NS_EXPORT ]( EX_CLASS, \"DELETE\", DELETE );\n})();";

    var d = BotanJS.import( "Dandelion" );
    var vimArea = d.id( "vim-area" );
    vimArea.value = TestString;

    window.VimArea = new ( BotanJS.import( "Components.Vim.VimArea" ) )( vimArea );

	var vimArea2 = d.id( "vim-area2" );
    vimArea2.value = "Since some textarea does not specify rows / cols\n\nI've made an experimental feature that automatically detects the screen size\nPlease file an issue if anything goes wrong with the rendering\n\nTo initialize with screen detection:\n\tnew VimArea( Element:TEXTAREA, DETECT_SCREEN_SIZE:Boolean );\n\nPress the button above to initialize a Vim instance.";

    var vimInit = d.id( "vim-init", true );

    vimInit.addEventListener( "Click", function(){
        window.VimArea2 = new ( BotanJS.import( "Components.Vim.VimArea" ) )( vimArea2, true );
    });
})();
</script>
</body>
</html>
